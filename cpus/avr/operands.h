/* AVR operand substitution routines
 * 
 * Most of AVR instructions are generated by substituting
 * operand values into some "base" opcode.
 * 
 * Example:
 * CBI A,b -> 1001 1000 AAAA Abbb
 * CBI 2,6 -> 1001 1000 0001 0110
 * 
 * Functions in this file take the "base" opcode along with
 * the instruction struct (which contains the operands that
 * we parsed) and generate the final instruction. They also
 * perform bound checking.
 */
/* FIXME: Finding better names for these functions is harder
 * than it sounds.
 */

/* 1 at bit position n */
#define BIT(n) (utaddr)(1 << n)

/* ____ __rd dddd rrrr
 * 0 <= r <= 31
 * 0 <= d <= 31
 */
static utaddr so_0(instruction *ip, utaddr opcode)
{
  taddr r;
  taddr d;

  r = ip->op[0]->value.c.val;
  d = ip->op[1]->value.c.val;

  if (r < 0 || r > 31 || d < 0 || d > 31)
    cpu_error(0); /* op value out of range */

  if (r & BIT(9))
    opcode |= (r & BIT(9));
  opcode |= (r << 4);
  opcode |= r;

  return opcode;
}

/* ____ ____ KKdd KKKK
 * d = 24 | 26 | 28 | 30
 * 0 <= K <= 63
 */
static utaddr so_1(instruction *ip, utaddr opcode)
{
  taddr d;
  taddr k;

  d = ip->op[0]->value.c.val;
  k = ip->op[1]->value.c.val;

  if (d != 24 && d != 26 && d != 28 && d != 30)
    cpu_error(0); /* op value out of range */
  if (k < 0 || k > 63)
    cpu_error(0);

  if (k & BIT(7))
    opcode |= BIT(7);
  if (k & BIT(6))
    opcode |= BIT(6);
  opcode |= (k & 0x000F);
  d -= 24;
  opcode |= (d << 4);

  return opcode;
}

/* ____ KKKK dddd KKKK
 * 16 <= d <= 31
 * 0 <= K <= 255
 */
static utaddr so_2(instruction *ip, utaddr opcode)
{
  taddr d;
  taddr k;

  d = ip->op[0]->value.c.val;
  k = ip->op[1]->value.c.val;

  if (d < 16 || d > 31 || k < 0 || k > 255)
    cpu_error(0); /* op value out of range */

  opcode |= (k << 8) & 0x0F00;
  opcode |= k & 0x000F;
  opcode |= d << 4;

  return opcode;
}

/* ____ ___d dddd ____
 * 0 <= d <= 31
 */
static utaddr so_3(instruction *ip, utaddr opcode);

/* ____ ____ _sss ____
 * 0 <= s <= 7
 */
static utaddr so_4(instruction *ip, utaddr opcode);

/* ____ ___d dddd _bbb
 * 0 <= d <= 31
 * 0 <= b <= 7
 */
static utaddr so_5(instruction *ip, utaddr opcode);

/* ____ __kk kkkk ksss
 * 0 <= s <= 7
 * -64 <= k <= +63
 */
static utaddr so_6(instruction *ip, utaddr opcode);

/* ____ __kk kkkk k___
 * -64 <= k <= +63
 */
static utaddr so_7(instruction *ip, utaddr opcode);

/* ____ ___k kkkk ___k
 * kkkk kkkk kkkk kkkk
 * jmp:      0 <= k < 4M  (4M when available)
 * call(i):  0 <= k < 64K (devices with 16-bit pc)
 * call(ii): 0 <= k < 4M  (devices with 22-bit pc)
 */
static utaddr so_8(instruction *ip, utaddr opcode);

/* ____ ____ AAAA Abbb
 * 0 <= A <= 31
 * 0 <= b <= 7
 */
static utaddr so_9(instruction *ip, utaddr opcode);

/* ____ __dd dddd dddd
 * 0 <= d <= 31  
 */
static utaddr so_10(instruction *ip, utaddr opcode);

/* ____ ____ KKKK ____
 * 0x00 <= K <= 0x0F
 */
static utaddr so_11(instruction *ip, utaddr opcode);

/* ____ ____ _ddd _rrr
 * 16 <= d <= 23
 * 16 <= r <= 23
 */
static utaddr so_12(instruction *ip, utaddr opcode);

/* ____ _AAd dddd AAAA
 * 0 <= d <= 31
 * 0 <= A <= 63
 */
static utaddr so_13(instruction *ip, utaddr opcode);

/* __q_ qq_d dddd _qqq
 * 0 <= r <= 31
 * 0 <= q <= 63
 */
static utaddr so_14(instruction *ip, utaddr opcode);

/* ____ ___d dddd ____
 * kkkk kkkk kkkk kkkk
 * 0 <= d <= 31
 * 0 <= k <= 65535
 */
static utaddr so_15(instruction *ip, utaddr opcode);

/* ____ _kkk dddd kkkk
 * 16 <= r <= 31
 * 0 <= k <= 127
 */
static utaddr so_16(instruction *ip, utaddr opcode);


/* ____ ____ dddd rrrr
 * 16 <= d <= 31
 * 16 <= r <= 31
 */
static utaddr so_17(instruction *ip, utaddr opcode);

/* ____ ____ dddd rrrr
 * d = {0,2,..,30}
 * r = {0,2,..,30}
 */
static utaddr so_18(instruction *ip, utaddr opcode);

/* ____ kkkk kkkk kkkk
 * -2K <= k <= 2K
 */
static utaddr so_19(instruction *ip, utaddr opcode);

/* ____ ____ dddd ____
 * 16 <= d <= 31
 */
static utaddr so_20(instruction *ip, utaddr opcode);